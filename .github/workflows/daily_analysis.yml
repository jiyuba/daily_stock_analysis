name: 每日股票分析

on:
  # 定时触发 - 每天北京时间 18:00 (UTC 10:00)
  schedule:
    - cron: '0 10 * * 1-5'  # 周一到周五，UTC 10:00 = 北京时间 18:00
  
  # 手动触发
  workflow_dispatch:
    inputs:
      mode:
        description: '运行模式'
        required: true
        default: 'full'
        type: choice
        options:
          - full          # 完整分析（股票+大盘）
          - market-only   # 仅大盘复盘
          - stocks-only   # 仅股票分析

jobs:
  analyze:
    runs-on: ubuntu-latest
    
    steps:
      - name: 检出代码
        uses: actions/checkout@v4
      
      - name: 设置 Python 环境
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'
      
      - name: 安装依赖
        run: |
          pip install --upgrade pip
          pip install -r requirements.txt
      
      - name: 创建必要目录
        run: |
          mkdir -p data logs reports
      
      - name: 执行股票分析
        env:
          # Gemini AI
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          GEMINI_MODEL: ${{ secrets.GEMINI_MODEL || 'gemini-3-flash-preview' }}
          GEMINI_MODEL_FALLBACK: ${{ secrets.GEMINI_MODEL_FALLBACK || 'gemini-2.5-flash' }}
          GEMINI_REQUEST_DELAY: '3.0'  # GitHub Actions 建议增加延时
          
          # 数据源 (可选)
          TUSHARE_TOKEN: ${{ secrets.TUSHARE_TOKEN }}
          
          # 搜索服务
          TAVILY_API_KEYS: ${{ secrets.TAVILY_API_KEYS }}
          SERPAPI_API_KEYS: ${{ secrets.SERPAPI_API_KEYS }}
          
          # OpenAI 兼容 API（备选）
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          OPENAI_BASE_URL: ${{ secrets.OPENAI_BASE_URL }}
          OPENAI_MODEL: ${{ secrets.OPENAI_MODEL }}
          
          # 通知渠道（可同时配置多个，全部推送）
          # 方式一：企业微信
          WECHAT_WEBHOOK_URL: ${{ secrets.WECHAT_WEBHOOK_URL }}
          # 方式二：飞书
          FEISHU_WEBHOOK_URL: ${{ secrets.FEISHU_WEBHOOK_URL }}
          # 方式三：Telegram（需同时配置 Bot Token 和 Chat ID）
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
          # 方式四：邮件（只需邮箱和授权码，SMTP自动识别）
          EMAIL_SENDER: ${{ secrets.EMAIL_SENDER }}
          EMAIL_PASSWORD: ${{ secrets.EMAIL_PASSWORD }}
          EMAIL_RECEIVERS: ${{ secrets.EMAIL_RECEIVERS }}
          # 方式五：自定义 Webhook（支持钉钉、Discord、Slack、Bark等，多个用逗号分隔）
          CUSTOM_WEBHOOK_URLS: ${{ secrets.CUSTOM_WEBHOOK_URLS }}
          # 方式六：飞书文档
          FEISHU_APP_ID: ${{ secrets.FEISHU_APP_ID }}
          FEISHU_APP_SECRET: ${{ secrets.FEISHU_APP_SECRET }}
          FEISHU_FOLDER_TOKEN: ${{ secrets.FEISHU_FOLDER_TOKEN }}

          
          # 自选股列表 (从 secrets 或使用默认值)
          STOCK_LIST: ${{ secrets.STOCK_LIST || '600519' }}
          
          # 其他配置
          LOG_LEVEL: INFO
          DATA_DAYS: 60
          MAX_CONCURRENT: 3
        run: |
          # 判断运行模式
          MODE="${{ github.event.inputs.mode || 'full' }}"
          
          echo "=========================================="
          echo "运行模式: $MODE"
          echo "自选股: $STOCK_LIST"
          echo "时间: $(TZ='Asia/Shanghai' date '+%Y-%m-%d %H:%M:%S')"
          echo "=========================================="
          
          if [ "$MODE" = "market-only" ]; then
            python main.py --market-review
          elif [ "$MODE" = "stocks-only" ]; then
            python main.py --no-market-review
          else
            python main.py
          fi
      
      - name: 上传分析报告
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: analysis-reports-${{ github.run_number }}
          path: |
            reports/
            logs/
          retention-days: 30
      
      - name: 显示运行结果
        if: always()
        run: |
          echo "=========================================="
          echo "分析完成"
          echo "=========================================="
          if [ -d "reports" ]; then
            echo "生成的报告:"
            ls -la reports/
          fi
          
      - name: 通过企业微信机器人发送通知
        if: always()
        env:
          JOB_STATUS: ${{ job.status }}
          MODE: ${{ github.event.inputs.mode || 'full' }}
          WEBHOOK_URL: ${{ secrets.WECHAT_WEBHOOK_URL }}
        run: |
          echo "正在准备发送企业微信通知..."

          # 1. 基础信息设置
          if [ "$JOB_STATUS" = "success" ]; then
            COLOR="#008000"
            EMOJI="✅"
          else
            COLOR="#FF0000"
            EMOJI="❌"
          fi
          CURRENT_TIME=$(date '+%Y-%m-%d %H:%M:%S')
          export COLOR EMOJI JOB_STATUS MODE CURRENT_TIME

          # 2. 使用Python完成：查找报告、智能拆分并发送
          python3 << 'EOF'
import os, json, urllib.request, glob, time

webhook_url = os.environ.get('WEBHOOK_URL')
if not webhook_url:
    print("❌ 错误: WEBHOOK_URL 环境变量未设置")
    exit(1)

color = os.environ.get('COLOR')
emoji = os.environ.get('EMOJI')
job_status = os.environ.get('JOB_STATUS')
mode = os.environ.get('MODE')
current_time = os.environ.get('CURRENT_TIME')

def send_wechat_message(webhook, content):
    """发送消息到企业微信机器人的通用函数"""
    data = {
        "msgtype": "markdown",
        "markdown": {
            "content": content
        }
    }
    try:
        req = urllib.request.Request(
            webhook,
            data=json.dumps(data, ensure_ascii=False).encode('utf-8'),
            headers={'Content-Type': 'application/json'}
        )
        with urllib.request.urlopen(req) as response:
            result = json.loads(response.read().decode('utf-8'))
            if result.get('errcode') == 0:
                return True
            else:
                print(f"❌ 消息发送失败: {result.get('errmsg')}")
                return False
    except Exception as e:
        print(f"❌ 请求发送失败: {e}")
        return False

# ========== 1. 查找报告文件 ==========
report_files = sorted(glob.glob('reports/report_*.md'))
if not report_files:
    print("未找到报告文件，发送状态通知。")
    status_content = f'''## {emoji} 股票分析任务完成
**运行状态:** <font color="{color}">{job_status}</font>
**分析模式:** {mode}
**完成时间:** {current_time}
> 未找到详细分析报告文件。'''
    if send_wechat_message(webhook_url, status_content):
        print("✅ 状态通知发送成功。")
    exit(0)

report_path = report_files[-1]
print(f"找到报告文件: {report_path}，准备发送全文...")

# ========== 2. 读取报告并准备拆分 ==========
with open(report_path, 'r', encoding='utf-8') as f:
    full_content = f.read()

total_len = len(full_content)
print(f"报告总长度: {total_len} 字符")

# 企业微信单条消息限制约4000字符，设置安全阈值
MAX_MSG_LEN = 3800

# ========== 3. 智能拆分逻辑 ==========
def split_content(content, max_len):
    """将内容智能拆分为多个块"""
    # 优先按段落拆分
    paragraphs = content.split('\n\n')
    chunks = []
    current_chunk = ""

    for para in paragraphs:
        # 如果段落本身超长，按固定长度硬拆分
        if len(para) > max_len:
            if current_chunk:
                chunks.append(current_chunk.strip())
                current_chunk = ""
            # 将超长段落拆分为多个块
            for i in range(0, len(para), max_len):
                chunks.append(para[i:i+max_len])
        elif len(current_chunk) + len(para) + 2 <= max_len:
            current_chunk += para + '\n\n'
        else:
            chunks.append(current_chunk.strip())
            current_chunk = para + '\n\n'

    if current_chunk:
        chunks.append(current_chunk.strip())

    return chunks

# ========== 4. 发送消息 ==========
if total_len <= MAX_MSG_LEN:
    print("报告较短，直接发送单条消息。")
    message_content = f'''## {emoji} 股票分析报告（全文）
**运行状态:** <font color="{color}">{job_status}</font>
**模式:** {mode} | **时间:** {current_time}
---
{full_content}'''

    if send_wechat_message(webhook_url, message_content):
        print("✅ 报告全文发送成功！")
else:
    print("报告较长，将拆分为多条消息发送。")
    chunks = split_content(full_content, MAX_MSG_LEN)
    total_chunks = len(chunks)
    print(f"报告将拆分为 {total_chunks} 条消息发送。")

    # 4.1 发送总览消息
    overview_content = f'''## {emoji} 股票分析报告（全文，共{total_chunks}部分）
**运行状态:** <font color="{color}">{job_status}</font>
**分析模式:** {mode}
**完成时间:** {current_time}
**报告长度:** {total_len} 字符
---
报告较长，将分多条消息发送，请稍候...'''

    if send_wechat_message(webhook_url, overview_content):
        print("✅ 已发送总览消息。")

    # 4.2 发送各个报告部分
    for idx, chunk in enumerate(chunks, 1):
        chunk_content = f'''### 报告部分 ({idx}/{total_chunks})
{chunk}
---
[{idx}/{total_chunks}]'''

        if send_wechat_message(webhook_url, chunk_content):
            print(f"✅ 已发送报告部分 {idx}/{total_chunks} (长度: {len(chunk)} 字符)")

        # 短暂延时，避免发送过快
        if idx < total_chunks:
            time.sleep(0.5)

    print(f"✅ 报告全文发送完成，共 {total_chunks} 条消息。")
EOF
